- label: fib
  enable: true
  input: |
    def + = { #(x, y,) -> prim(add, x, y) }
    def zipWith = {
      #(f, xs, ys).head -> f(xs.head, ys.head),
      #(f, xs, ys).tail -> zipWith(f, xs.tail, ys.tail),
    }
    def fib = {
      #.head -> 1,
      #.tail.head -> 1,
      #.tail.tail -> zipWith({#(x, y) -> x + y}, fib, fib.tail),
    }
    def main = { #() -> fib.tail.tail.tail.head }
  expected:
    parser: |
      (def + (codata (clause (call # (var x) (var y)) (prim add (var x) (var y)))))
      (def zipWith (codata (clause (access (call # (var f) (var xs) (var ys)) head) (call (var f) (access (var xs) head) (access (var ys) head))) (clause (access (call # (var f) (var xs) (var ys)) tail) (call (var zipWith) (var f) (access (var xs) tail) (access (var ys) tail)))))
      (def fib (codata (clause (access # head) (literal 1)) (clause (access (access # tail) head) (literal 1)) (clause (access (access # tail) tail) (call (var zipWith) (codata (clause (call # (var x) (var y)) (binary (var x) + (var y)))) (var fib) (access (var fib) tail)))))
      (def main (codata (clause (call #) (access (access (access (access (var fib) tail) tail) tail) head))))
    codata: |
      (def + (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim add (var x) (var y))))))
      (def zipWith (lambda (x0 x1 x2) (object (field head (case ((var x0) (var x1) (var x2)) (clause ((var f) (var xs) (var ys)) (call (var f) (access (var xs) head) (access (var ys) head))))) (field tail (case ((var x0) (var x1) (var x2)) (clause ((var f) (var xs) (var ys)) (call (var zipWith) (var f) (access (var xs) tail) (access (var ys) tail))))))))
      (def fib (object (field head (literal 1)) (field tail (object (field head (literal 1)) (field tail (call (var zipWith) (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (binary (var x) + (var y))))) (var fib) (access (var fib) tail)))))))
      (def main (lambda () (access (access (access (access (var fib) tail) tail) tail) head)))
    infix: |
      (def + (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim add (var x) (var y))))))
      (def zipWith (lambda (x0 x1 x2) (object (field head (case ((var x0) (var x1) (var x2)) (clause ((var f) (var xs) (var ys)) (call (var f) (access (var xs) head) (access (var ys) head))))) (field tail (case ((var x0) (var x1) (var x2)) (clause ((var f) (var xs) (var ys)) (call (var zipWith) (var f) (access (var xs) tail) (access (var ys) tail))))))))
      (def fib (object (field head (literal 1)) (field tail (object (field head (literal 1)) (field tail (call (var zipWith) (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (binary (var x) + (var y))))) (var fib) (access (var fib) tail)))))))
      (def main (lambda () (access (access (access (access (var fib) tail) tail) tail) head)))
    nameresolve: |
      (def +.0 (lambda (x0.4 x1.5) (case ((var x0.4) (var x1.5)) (clause ((var x.6) (var y.7)) (prim add (var x.6) (var y.7))))))
      (def zipWith.1 (lambda (x0.8 x1.9 x2.10) (object (field head (case ((var x0.8) (var x1.9) (var x2.10)) (clause ((var f.11) (var xs.12) (var ys.13)) (call (var f.11) (access (var xs.12) head) (access (var ys.13) head))))) (field tail (case ((var x0.8) (var x1.9) (var x2.10)) (clause ((var f.14) (var xs.15) (var ys.16)) (call (var zipWith.1) (var f.14) (access (var xs.15) tail) (access (var ys.16) tail))))))))
      (def fib.2 (object (field head (literal 1)) (field tail (object (field head (literal 1)) (field tail (call (var zipWith.1) (lambda (x0.17 x1.18) (case ((var x0.17) (var x1.18)) (clause ((var x.19) (var y.20)) (binary (var x.19) +.0 (var y.20))))) (var fib.2) (access (var fib.2) tail)))))))
      (def main.3 (lambda () (access (access (access (access (var fib.2) tail) tail) tail) head)))
    eval: 3
- label: tree
  enable: true
  input: |
    type Int     = prim(int)
    type List(a) = Nil() | Cons(a, List)
    infixl 6 -
    def - = { #(x, y) -> prim(sub, x, y) }
    def map = {
      #(f, Nil()) -> Nil(),
      #(f, Cons(x, xs)) -> Cons(f(x), map(f, xs)),
    }
    def prune = {
      #(x,t).node -> t.node,
      #(0,t).children -> Nil,
      #(x,t).children -> map(prune(x-1), t.children),
    }
    def tree = {
      #.node -> 1,
      #.children -> Cons(tree1, Cons(tree2, Nil())),
    }
    def tree1 = {
      #.node -> 2,
      #.children -> Nil(),
    }
    def tree2 = {
      #.node -> 3,
      #.children -> Cons(tree, Nil()),
    }
    def main = { #() -> prune(2, tree) }
  expected:
    parser: |
      (type (var Int) (prim int))
      (type (call (var List) (var a)) (call (var Nil)) (call (var Cons) (var a) (var List)))
      (infix infixl 6 -)
      (def - (codata (clause (call # (var x) (var y)) (prim sub (var x) (var y)))))
      (def map (codata (clause (call # (var f) (call (var Nil))) (call (var Nil))) (clause (call # (var f) (call (var Cons) (var x) (var xs))) (call (var Cons) (call (var f) (var x)) (call (var map) (var f) (var xs))))))
      (def prune (codata (clause (access (call # (var x) (var t)) node) (access (var t) node)) (clause (access (call # (literal 0) (var t)) children) (var Nil)) (clause (access (call # (var x) (var t)) children) (call (var map) (call (var prune) (binary (var x) - (literal 1))) (access (var t) children)))))
      (def tree (codata (clause (access # node) (literal 1)) (clause (access # children) (call (var Cons) (var tree1) (call (var Cons) (var tree2) (call (var Nil)))))))
      (def tree1 (codata (clause (access # node) (literal 2)) (clause (access # children) (call (var Nil)))))
      (def tree2 (codata (clause (access # node) (literal 3)) (clause (access # children) (call (var Cons) (var tree) (call (var Nil))))))
      (def main (codata (clause (call #) (call (var prune) (literal 2) (var tree)))))
    codata: |
      (type (var Int) (prim int))
      (type (call (var List) (var a)) (call (var Nil)) (call (var Cons) (var a) (var List)))
      (infix infixl 6 -)
      (def - (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim sub (var x) (var y))))))
      (def map (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var f) (call (var Nil))) (call (var Nil))) (clause ((var f) (call (var Cons) (var x) (var xs))) (call (var Cons) (call (var f) (var x)) (call (var map) (var f) (var xs)))))))
      (def prune (lambda (x0 x1) (object (field children (case ((var x0) (var x1)) (clause ((literal 0) (var t)) (var Nil)) (clause ((var x) (var t)) (call (var map) (call (var prune) (binary (var x) - (literal 1))) (access (var t) children))))) (field node (case ((var x0) (var x1)) (clause ((var x) (var t)) (access (var t) node)))))))
      (def tree (object (field children (call (var Cons) (var tree1) (call (var Cons) (var tree2) (call (var Nil))))) (field node (literal 1))))
      (def tree1 (object (field children (call (var Nil))) (field node (literal 2))))
      (def tree2 (object (field children (call (var Cons) (var tree) (call (var Nil)))) (field node (literal 3))))
      (def main (lambda () (call (var prune) (literal 2) (var tree))))
    infix: |
      (type (var Int) (prim int))
      (type (call (var List) (var a)) (call (var Nil)) (call (var Cons) (var a) (var List)))
      (infix infixl 6 -)
      (def - (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim sub (var x) (var y))))))
      (def map (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var f) (call (var Nil))) (call (var Nil))) (clause ((var f) (call (var Cons) (var x) (var xs))) (call (var Cons) (call (var f) (var x)) (call (var map) (var f) (var xs)))))))
      (def prune (lambda (x0 x1) (object (field children (case ((var x0) (var x1)) (clause ((literal 0) (var t)) (var Nil)) (clause ((var x) (var t)) (call (var map) (call (var prune) (binary (var x) - (literal 1))) (access (var t) children))))) (field node (case ((var x0) (var x1)) (clause ((var x) (var t)) (access (var t) node)))))))
      (def tree (object (field children (call (var Cons) (var tree1) (call (var Cons) (var tree2) (call (var Nil))))) (field node (literal 1))))
      (def tree1 (object (field children (call (var Nil))) (field node (literal 2))))
      (def tree2 (object (field children (call (var Cons) (var tree) (call (var Nil)))) (field node (literal 3))))
      (def main (lambda () (call (var prune) (literal 2) (var tree))))
    nameresolve: |
      (type (var Int.0) (prim int))
      (type (call (var List.1) (var a.2)) (call (var Nil.3)) (call (var Cons.4) (var a.2) (var List.1)))
      (infix infixl 6 -.5)
      (def -.5 (lambda (x0.12 x1.13) (case ((var x0.12) (var x1.13)) (clause ((var x.14) (var y.15)) (prim sub (var x.14) (var y.15))))))
      (def map.6 (lambda (x0.16 x1.17) (case ((var x0.16) (var x1.17)) (clause ((var f.18) (call (var Nil.3))) (call (var Nil.3))) (clause ((var f.19) (call (var Cons.4) (var x.20) (var xs.21))) (call (var Cons.4) (call (var f.19) (var x.20)) (call (var map.6) (var f.19) (var xs.21)))))))
      (def prune.7 (lambda (x0.22 x1.23) (object (field children (case ((var x0.22) (var x1.23)) (clause ((literal 0) (var t.24)) (var Nil.3)) (clause ((var x.25) (var t.26)) (call (var map.6) (call (var prune.7) (binary (var x.25) -.5 (literal 1))) (access (var t.26) children))))) (field node (case ((var x0.22) (var x1.23)) (clause ((var x.27) (var t.28)) (access (var t.28) node)))))))
      (def tree.8 (object (field children (call (var Cons.4) (var tree1.9) (call (var Cons.4) (var tree2.10) (call (var Nil.3))))) (field node (literal 1))))
      (def tree1.9 (object (field children (call (var Nil.3))) (field node (literal 2))))
      (def tree2.10 (object (field children (call (var Cons.4) (var tree.8) (call (var Nil.3)))) (field node (literal 3))))
      (def main.11 (lambda () (call (var prune.7) (literal 2) (var tree.8))))
    eval: <object>
- label: infix
  enable: true
  input: |
    infixl 6 +
    infixl 8 *
    def + = { #(x, y) -> prim(add, x, y) }
    def * = { #(x, y) -> prim(mul, x, y) }
    def main = { #() -> 1 + 2 * 3 }
  expected:
    parser: |
      (infix infixl 6 +)
      (infix infixl 8 *)
      (def + (codata (clause (call # (var x) (var y)) (prim add (var x) (var y)))))
      (def * (codata (clause (call # (var x) (var y)) (prim mul (var x) (var y)))))
      (def main (codata (clause (call #) (binary (binary (literal 1) + (literal 2)) * (literal 3)))))
    codata: |
      (infix infixl 6 +)
      (infix infixl 8 *)
      (def + (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim add (var x) (var y))))))
      (def * (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim mul (var x) (var y))))))
      (def main (lambda () (binary (binary (literal 1) + (literal 2)) * (literal 3))))
    infix: |
      (infix infixl 6 +)
      (infix infixl 8 *)
      (def + (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim add (var x) (var y))))))
      (def * (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim mul (var x) (var y))))))
      (def main (lambda () (binary (literal 1) + (binary (literal 2) * (literal 3)))))
    nameresolve: |
      (infix infixl 6 +.0)
      (infix infixl 8 *.1)
      (def +.0 (lambda (x0.3 x1.4) (case ((var x0.3) (var x1.4)) (clause ((var x.5) (var y.6)) (prim add (var x.5) (var y.6))))))
      (def *.1 (lambda (x0.7 x1.8) (case ((var x0.7) (var x1.8)) (clause ((var x.9) (var y.10)) (prim mul (var x.9) (var y.10))))))
      (def main.2 (lambda () (binary (literal 1) +.0 (binary (literal 2) *.1 (literal 3)))))
    eval: 7
- label: infix2
  enable: true
  input: |
    infixl 6 +
    infixl 8 *
    def + = { #(x, y) -> prim(add, x, y) }
    def * = { #(x, y) -> prim(mul, x, y) }
    def main = { #() -> 1 * 2 + 3 }
  expected:
    parser: |
      (infix infixl 6 +)
      (infix infixl 8 *)
      (def + (codata (clause (call # (var x) (var y)) (prim add (var x) (var y)))))
      (def * (codata (clause (call # (var x) (var y)) (prim mul (var x) (var y)))))
      (def main (codata (clause (call #) (binary (binary (literal 1) * (literal 2)) + (literal 3)))))
    codata: |
      (infix infixl 6 +)
      (infix infixl 8 *)
      (def + (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim add (var x) (var y))))))
      (def * (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim mul (var x) (var y))))))
      (def main (lambda () (binary (binary (literal 1) * (literal 2)) + (literal 3))))
    infix: |
      (infix infixl 6 +)
      (infix infixl 8 *)
      (def + (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim add (var x) (var y))))))
      (def * (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim mul (var x) (var y))))))
      (def main (lambda () (binary (binary (literal 1) * (literal 2)) + (literal 3))))
    nameresolve: |
      (infix infixl 6 +.0)
      (infix infixl 8 *.1)
      (def +.0 (lambda (x0.3 x1.4) (case ((var x0.3) (var x1.4)) (clause ((var x.5) (var y.6)) (prim add (var x.5) (var y.6))))))
      (def *.1 (lambda (x0.7 x1.8) (case ((var x0.7) (var x1.8)) (clause ((var x.9) (var y.10)) (prim mul (var x.9) (var y.10))))))
      (def main.2 (lambda () (binary (binary (literal 1) *.1 (literal 2)) +.0 (literal 3))))
    eval: 5
- label: infix3
  enable: true
  input: |
    infixl 6 +
    infixl 8 *
    def + = { #(x, y) -> prim(add, x, y) }
    def * = { #(x, y) -> prim(mul, x, y) }
    def main = { #() -> 1 * (2 + 3) }
  expected:
    parser: |
      (infix infixl 6 +)
      (infix infixl 8 *)
      (def + (codata (clause (call # (var x) (var y)) (prim add (var x) (var y)))))
      (def * (codata (clause (call # (var x) (var y)) (prim mul (var x) (var y)))))
      (def main (codata (clause (call #) (binary (literal 1) * (paren (binary (literal 2) + (literal 3)))))))
    codata: |
      (infix infixl 6 +)
      (infix infixl 8 *)
      (def + (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim add (var x) (var y))))))
      (def * (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim mul (var x) (var y))))))
      (def main (lambda () (binary (literal 1) * (paren (binary (literal 2) + (literal 3))))))
    infix: |
      (infix infixl 6 +)
      (infix infixl 8 *)
      (def + (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim add (var x) (var y))))))
      (def * (lambda (x0 x1) (case ((var x0) (var x1)) (clause ((var x) (var y)) (prim mul (var x) (var y))))))
      (def main (lambda () (binary (literal 1) * (binary (literal 2) + (literal 3)))))
    nameresolve: |
      (infix infixl 6 +.0)
      (infix infixl 8 *.1)
      (def +.0 (lambda (x0.3 x1.4) (case ((var x0.3) (var x1.4)) (clause ((var x.5) (var y.6)) (prim add (var x.5) (var y.6))))))
      (def *.1 (lambda (x0.7 x1.8) (case ((var x0.7) (var x1.8)) (clause ((var x.9) (var y.10)) (prim mul (var x.9) (var y.10))))))
      (def main.2 (lambda () (binary (literal 1) *.1 (binary (literal 2) +.0 (literal 3)))))
    eval: 5
- label: method
  enable: true
  input: |
    def printer = {
      #.print -> fn (x) { prim(print, x) },
    }
    def main = { #() -> printer.print(1) }
  expected:
    parser: |
      (def printer (codata (clause (access # print) (lambda (x) (prim print (var x))))))
      (def main (codata (clause (call #) (call (access (var printer) print) (literal 1)))))
    codata: |
      (def printer (object (field print (lambda (x) (prim print (var x))))))
      (def main (lambda () (call (access (var printer) print) (literal 1))))
    infix: |
      (def printer (object (field print (lambda (x) (prim print (var x))))))
      (def main (lambda () (call (access (var printer) print) (literal 1))))
    nameresolve: |
      (def printer.0 (object (field print (lambda (x.2) (prim print (var x.2))))))
      (def main.1 (lambda () (call (access (var printer.0) print) (literal 1))))
    eval: <unit>
- label: method-copattern
  enable: false
  input: |
    def printer = {
      #.print(x) -> prim(print, x),
    }
    def main = { #() -> printer.print(1) }
  expected:
    parser: |
      (def printer (codata (clause (call (access # print) (var x)) (prim print (var x)))))
      (def main (codata (clause (call #) (call (access (var printer) print) (literal 1)))))
    codata: |
      (def printer (object (field print (lambda (x) (prim print (var x))))))
      (def main (lambda () (call (access (var printer) print) (literal 1))))
    infix: |
      (def printer (object (field print (lambda (x) (prim print (var x))))))
      (def main (lambda () (call (access (var printer) print) (literal 1))))
    nameresolve: |
      (def printer.0 (object (field print (lambda (x.2) (prim print (var x.2))))))
      (def main.1 (lambda () (call (access (var printer.0) print) (literal 1))))
    eval: <unit>
- label: vendor-statemachine
  enable: true
  input: |
    type Option(c) = None() | Some(c)
    type List(d) = Nil() | Cons(d, List(d))
    
    def vendor = {
        #(items).get -> None(),
        #(Nil()).put.get ->
            prim(print, "Nil case");
            prim(print, Nil());
            None,
        #(Cons(x, xs)).put.get ->
            prim(print, "Cons case");
            prim(print, Cons(x, xs));
            Some(x),
        #(items).put.put ->
            vendor(items).put,
    }
    
    def main = {
        #() -> vendor(Cons(0, Nil())).put.get
    }
  expected:
    parser: |
      (type (call (var Option) (var c)) (call (var None)) (call (var Some) (var c)))
      (type (call (var List) (var d)) (call (var Nil)) (call (var Cons) (var d) (call (var List) (var d))))
      (def vendor (codata (clause (access (call # (var items)) get) (call (var None))) (clause (access (access (call # (call (var Nil))) put) get) (prim print (literal "Nil case")) (prim print (call (var Nil))) (var None)) (clause (access (access (call # (call (var Cons) (var x) (var xs))) put) get) (prim print (literal "Cons case")) (prim print (call (var Cons) (var x) (var xs))) (call (var Some) (var x))) (clause (access (access (call # (var items)) put) put) (access (call (var vendor) (var items)) put))))
      (def main (codata (clause (call #) (access (access (call (var vendor) (call (var Cons) (literal 0) (call (var Nil)))) put) get))))
    codata: |
      (type (call (var Option) (var c)) (call (var None)) (call (var Some) (var c)))
      (type (call (var List) (var d)) (call (var Nil)) (call (var Cons) (var d) (call (var List) (var d))))
      (def vendor (lambda (x0) (object (field get (case ((var x0)) (clause (var items) (call (var None))))) (field put (object (field get (case ((var x0)) (clause (call (var Nil)) (prim print (literal "Nil case")) (prim print (call (var Nil))) (var None)) (clause (call (var Cons) (var x) (var xs)) (prim print (literal "Cons case")) (prim print (call (var Cons) (var x) (var xs))) (call (var Some) (var x))))) (field put (case ((var x0)) (clause (var items) (access (call (var vendor) (var items)) put)))))))))
      (def main (lambda () (access (access (call (var vendor) (call (var Cons) (literal 0) (call (var Nil)))) put) get)))
    infix: |
      (type (call (var Option) (var c)) (call (var None)) (call (var Some) (var c)))
      (type (call (var List) (var d)) (call (var Nil)) (call (var Cons) (var d) (call (var List) (var d))))
      (def vendor (lambda (x0) (object (field get (case ((var x0)) (clause (var items) (call (var None))))) (field put (object (field get (case ((var x0)) (clause (call (var Nil)) (prim print (literal "Nil case")) (prim print (call (var Nil))) (var None)) (clause (call (var Cons) (var x) (var xs)) (prim print (literal "Cons case")) (prim print (call (var Cons) (var x) (var xs))) (call (var Some) (var x))))) (field put (case ((var x0)) (clause (var items) (access (call (var vendor) (var items)) put)))))))))
      (def main (lambda () (access (access (call (var vendor) (call (var Cons) (literal 0) (call (var Nil)))) put) get)))
    nameresolve: |
      (type (call (var Option.0) (var c.1)) (call (var None.2)) (call (var Some.3) (var c.1)))
      (type (call (var List.4) (var d.5)) (call (var Nil.6)) (call (var Cons.7) (var d.5) (call (var List.4) (var d.5))))
      (def vendor.8 (lambda (x0.10) (object (field get (case ((var x0.10)) (clause (var items.11) (call (var None.2))))) (field put (object (field get (case ((var x0.10)) (clause (call (var Nil.6)) (prim print (literal "Nil case")) (prim print (call (var Nil.6))) (var None.2)) (clause (call (var Cons.7) (var x.12) (var xs.13)) (prim print (literal "Cons case")) (prim print (call (var Cons.7) (var x.12) (var xs.13))) (call (var Some.3) (var x.12))))) (field put (case ((var x0.10)) (clause (var items.14) (access (call (var vendor.8) (var items.14)) put)))))))))
      (def main.9 (lambda () (access (access (call (var vendor.8) (call (var Cons.7) (literal 0) (call (var Nil.6)))) put) get)))
    eval: Some.3(0)
