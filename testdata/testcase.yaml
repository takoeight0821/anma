- input: |
    def + = { #(x, y,) -> prim(add, x, y) }
    def zipWith = {
      #(f, xs, ys).head -> f(xs.head, ys.head),
      #(f, xs, ys).tail -> zipWith(f, xs.tail, ys.tail),
    }
    def fib = {
      #.head -> 1,
      #.tail.head -> 1,
      #.tail.tail -> zipWith({#(x, y) -> x + y}, fib, fib.tail),
    }
    def main = { #() -> fib(10) }
  expected:
    parser: |
      (def + (codata (clause (call (this #) (var x) (var y)) (prim add (var x) (var y)))))
      (def zipWith (codata (clause (access (call (this #) (var f) (var xs) (var ys)) head) (call (var f) (access (var xs) head) (access (var ys) head))) (clause (access (call (this #) (var f) (var xs) (var ys)) tail) (call (var zipWith) (var f) (access (var xs) tail) (access (var ys) tail)))))
      (def fib (codata (clause (access (this #) head) (literal 1)) (clause (access (access (this #) tail) head) (literal 1)) (clause (access (access (this #) tail) tail) (call (var zipWith) (codata (clause (call (this #) (var x) (var y)) (binary (var x) + (var y)))) (var fib) (access (var fib) tail)))))
      (def main (codata (clause (call (this #)) (call (var fib) (literal 10)))))
- input: |
    type List = Nil | Cons(Int, List)
    def map = {
      #(f, Nil) -> Nil,
      #(f, Cons(x, xs)) -> Cons(f(x), map(f, xs)),
    }
    def prune = {
      #(x,t).node -> t.node,
      #(0,t).children -> Nil,
      #(x,t).children -> map(prune(x-1), t.children),
    }
    def tree = {
      #.node -> 1,
      #.children -> Cons(tree1, Cons(tree2, Nil)),
    }
    def tree1 = {
      #.node -> 2,
      #.children -> Nil,
    }
    def tree2 = {
      #.node -> 3,
      #.children -> Cons(tree, Nil),
    }
    def main = { #() -> prune(2, tree) }
  expected:
    parser: |
      (type List (binary (var Nil) | (call (var Cons) (var Int) (var List))))
      (def map (codata (clause (call (this #) (var f) (var Nil)) (var Nil)) (clause (call (this #) (var f) (call (var Cons) (var x) (var xs))) (call (var Cons) (call (var f) (var x)) (call (var map) (var f) (var xs))))))
      (def prune (codata (clause (access (call (this #) (var x) (var t)) node) (access (var t) node)) (clause (access (call (this #) (literal 0) (var t)) children) (var Nil)) (clause (access (call (this #) (var x) (var t)) children) (call (var map) (call (var prune) (binary (var x) - (literal 1))) (access (var t) children)))))
      (def tree (codata (clause (access (this #) node) (literal 1)) (clause (access (this #) children) (call (var Cons) (var tree1) (call (var Cons) (var tree2) (var Nil))))))
      (def tree1 (codata (clause (access (this #) node) (literal 2)) (clause (access (this #) children) (var Nil))))
      (def tree2 (codata (clause (access (this #) node) (literal 3)) (clause (access (this #) children) (call (var Cons) (var tree) (var Nil)))))
      (def main (codata (clause (call (this #)) (call (var prune) (literal 2) (var tree)))))
