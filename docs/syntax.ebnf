(* Code generated by go generate; DO NOT EDIT. *)

expr = let | fn | assert ; (* type Node *)

var = IDENTIFIER ; (* type Var *)

literal = INTEGER | FLOAT | RUNE | STRING ; (* type Literal *)

paren = "(" expr ("," expr)* ","? ")" | "(" ")" ; (* type Paren *)

access = expr "." IDENTIFIER ; (* type Access *)

call = expr "(" ")" | expr "(" expr ("," expr)* ","? ")" ; (* type Call *)

binary = expr operator expr ; (* type Binary *)

assert = binop (":" type)* ; (* type Assert *)

let = "let" pattern "=" assert ; (* type Let *)

codata = "{" clause ("," clause)* ","? "}" ; (* type Codata *)

clause = pattern "->" expr (";" expr)* ";"? ; (* type Clause *)

fn = "fn" pattern "{" expr (";" expr)* ";"? "}" ; (* type Lambda *)

case = "case" expr "{" clause ("," clause)* ","? "}" ; (* type Case *)

object = "{" field ("," field)* ","? "}" ; (* type Object *)

field = IDENTIFIER ":" expr ; (* type Field *)

typeDecl = "type" IDENTIFIER "=" type ; (* type TypeDecl *)

varDecl = "def" identifier "=" expr | "def" identifier ":" type | "def" identifier ":" type "=" expr ; (* type VarDecl *)

infixDecl = ("infix" | "infixl" | "infixr") INTEGER IDENTIFIER ; (* type InfixDecl *)

